import java.util.*;
/*
СОБИРАЕМ ВСЕ ВМЕСТЕ (STREAM API)
Необходимо в списке отобрать первые 2 строки в алфавитном порядке, которые имеют длину 4.
 */
public class Solution14_5_0_2 {
    public static void main(String[] args) {
//        List<String> list = Arrays.asList("Toby", "Anna", "Leroy", "Alex"); //(1)
//        List<String> filtered = new ArrayList<>();  //a
//        for(String name:list)   {
//            if(name.length() == 4) {
//                filtered.add(name); //b
//            }
//        }
//
//        Collections.sort(filtered); //Сортирует указанный список в порядке возрастания в соответствии с естественным порядком его элементов.
//        Iterator<String> iter = filtered.iterator();    //c Возвращает итератор по элементам в этом списке в правильной последовательности.
//        if(iter.hasNext()) {    //d
//            System.out.println(iter.next());
//        }
//        if(iter.hasNext()) {    //d
//            System.out.println(iter.next());
//        }

        /*
        Этот код работает и решает нашу задачу. Но посмотрите, сколько важных тезисов о том, что этот код делает, буквально утопают в реализации!
        Нам нужно явно инициализировать новый лист(a), чтобы в него потом класть отфильтрованные элементы(b), нужно использовать итератор(c), чтобы пройти по листу ровно 2 раза
        (потому что нужно отобрать первые 2 строки, а итератор будет это делать первый раз затем счетчик внутри увеличится и второй раз нужно).
        При этом тут показана очень простая операция. Но «читать» её непросто. Лучше писать такой код, который использует декларативный подход.

        Теперь посмотрим, как мы можем решить ту же самую задачу, используя стримы:
         */

        List<String> list = Arrays.asList("Toby", "Anna", "Leroy", "Alex");
        list
                .stream()   //Возвращает последовательный поток с этой коллекцией в качестве источника.
                .filter(n -> n.length() == 4)   //Возвращает поток, состоящий из элементов этого потока, соответствующих заданному предикату.
                .sorted()   //Возвращает поток, состоящий из элементов этого потока, отсортированных в естественном порядке
                .limit(2)   //Возвращает поток, состоящий из элементов этого потока, усеченный так, чтобы его длина не превышала maxSize.
                .forEach(System.out::println);  //Выполняет действие для каждого элемента этого потока.
        /*
        Видите разницу? Теперь у нас каждый вызов метода, как отдельная декларативная операция.
        Нет необходимости работать с промежуточными переменными, код легко читаем, разбит на четкие задачи.
         */
    }
}

/*
1. asList() - Возвращает список фиксированного размера, поддерживаемый указанным массивом.
Изменения, внесенные в массив, будут видны в возвращаемом списке, а изменения, внесенные в список, будут видны в массиве
 */